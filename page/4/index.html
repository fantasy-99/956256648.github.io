<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="Fantasy&#39;s Blog">
<meta property="og:url" content="https://956256648.github.io/page/4/index.html">
<meta property="og:site_name" content="Fantasy&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Fantasy">
<meta name="twitter:card" content="summary"><title>Fantasy's Blog</title><link ref="canonical" href="https://956256648.github.io/page/4/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Fantasy's Blog</div><div class="header-banner-info__subtitle">隐约雷鸣 阴霾天空</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/01/26/%E5%88%A4%E7%8E%AF/">判环</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-01-26</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-01-26</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
      
<p>判环主要有三种方法</p>
<p>1.拓扑排序</p>
<p>2.dfs</p>
<p>3.并查集</p>
<p>前两种用的比较多，并查集可以有很多操作。另外floyd也可以判环。</p>

        <h1 id="源码"   >
          <a href="#源码" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#源码"></a> 源码</h1>
      

        <h2 id="拓扑排序"   >
          <a href="#拓扑排序" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#拓扑排序"></a> 拓扑排序</h2>
      
<ul>
<li>在判断无向图中是否存在环时，是将所有<strong>度 = 1</strong> 的结点入队，剩下的度大于等于2的点即是环上的点；</li>
<li>在判断有向图中是否存在环时，是将所有<strong>入度 = 0</strong> 的结点入队，剩下的度不为0的点即在环上。</li>
</ul>
<p>这里有一道无向图判环的题：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=7050" >HDU7050</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，看着像一道数学题，其实变换一下那个式子，就能发现很像置换，再化一化就能看出来和环有关，判断各个环的权值平均值是否相等，用top序过滤一下不在环上的边，因为这些边一定可以走到环上，之后模拟置换过程，算环的权值平均值，自环也算。</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ms=<span class="number">500009</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[ms],to[ms],ne[ms];</span><br><span class="line"><span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> du[ms];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> f[ms];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[++tot]=y;</span><br><span class="line">    ne[tot]=head[x];</span><br><span class="line">    head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topsort</span><span class="params">()</span><span class="comment">//无向图拓扑，过滤图，只剩环</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(du[i]==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x]; i; i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> y=to[i];</span><br><span class="line">            du[y]--;</span><br><span class="line">            <span class="keyword">if</span>(du[y]==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            head[i]=<span class="number">0</span>;</span><br><span class="line">            du[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tot=<span class="number">0</span>;</span><br><span class="line">        ll av=<span class="number">0</span>;<span class="comment">//分子</span></span><br><span class="line">        ll shu=<span class="number">0</span>;<span class="comment">//分母</span></span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x,y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;y);</span><br><span class="line">            x=i;</span><br><span class="line">            add(x,y);</span><br><span class="line">            add(y,x);</span><br><span class="line">            f[x]=y;</span><br><span class="line">            du[x]++; du[y]++;</span><br><span class="line">        &#125;</span><br><span class="line">        topsort();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(du[i]&lt;=<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            ll cnt;</span><br><span class="line">            ll sum;</span><br><span class="line">            <span class="keyword">int</span> x=i,y=f[i];</span><br><span class="line">            cnt=<span class="number">1</span>;</span><br><span class="line">            sum=x;</span><br><span class="line">            du[x]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(du[y]&gt;=<span class="number">2</span>)<span class="comment">//置换，直到走回原位置</span></span><br><span class="line">            &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                sum+=y;</span><br><span class="line">                du[y]=<span class="number">0</span>;</span><br><span class="line">                x=y;</span><br><span class="line">                y=f[y];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(shu==<span class="number">0</span>)<span class="comment">//之前还没环，则先赋值</span></span><br><span class="line">            &#123;</span><br><span class="line">                shu=cnt;</span><br><span class="line">                av=sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(shu*sum!=av*cnt)<span class="comment">//如果两个环的均值不相等，说明不行。</span></span><br><span class="line">                &#123;</span><br><span class="line">                    flag=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

        <h2 id="dfs"   >
          <a href="#dfs" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#dfs"></a> dfs</h2>
      
<p>使用 DFS 可以判断一个无向图和有向中是否存在环。深度优先遍历图，如果在遍历的过程中，发现某个结点有一条边指向已访问过的结点，并且这个已访问过的结点不是上一步访问的结点，则表示存在环。</p>
<p>我们不能仅仅使用一个 bool 数组来表示结点是否访问过。规定每个结点都拥有三种状态，白、灰、黑。开始时所有结点都是白色，当访问过某个结点后，该结点变为灰色，当该结点的所有邻接点都访问完，该节点变为黑色。</p>
<p>那么我们的算法可以表示为：如果在遍历的过程中，发现某个结点有一条边指向灰色节点，并且这个灰色结点不是上一步访问的结点，那么存在环。</p>

        <h2 id="并查集"   >
          <a href="#并查集" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h2>
      
<p>之前用并查集写过一到最小环的题，感觉上面可以进行的操作还是挺多的。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2661" >P2661</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	cnt++;</span></span><br><span class="line">	<span class="keyword">return</span> (f[x]==x)?x:(get(f[x]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/01/26/rmq%E5%92%8Cst/">rmq和st</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-01-26</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-01-26</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
      
<p>rmq区间最值问题，著名的st算法常被用来解决这个问题，需要先了解一下倍增思想。</p>
<p>可以O（NlogN）预处理出区间，然后O（1）查询。</p>
<p>st[i,j]表示子区间[i,i+2<sup>j−1]里的最大值，那么我们可以得出一个递推式子st[i,j]=max(st[i,j−1],st[i+2</sup>(j-1),j−1])。即子区间的长度成倍增长，长度为2<sup>j的子区间是左右两半长度为2</sup>(j-1)的子区间中最大值较大的一个。这样就能处理出所有区间最值。</p>
<p>询问时，先算一个k，满足2<sup>k&lt;=r−l+1&lt;2</sup>(k+1)，也就是2的k次幂小于区间长度下的最大k，然后从l开始的2<sup>k个数和以r结尾的2</sup>k的个数这两段一定覆盖了整个区间[l,r]，重叠一部分也没关系。</p>

        <h1 id="源码"   >
          <a href="#源码" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#源码"></a> 源码</h1>
      
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span><span class="comment">//rmq询问</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="built_in">log</span>(r-l+<span class="number">1</span>)/<span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> max(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initrmq</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        st[i][<span class="number">0</span>]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tt=<span class="built_in">log</span>(n)/<span class="built_in">log</span>(<span class="number">2</span>);<span class="comment">//rmq预处理区间最值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=tt; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i+(<span class="number">1</span>&lt;&lt;j)&lt;=n+<span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[i][j]=max(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>下面是21牛客多校8的J题：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/11259/J" >21牛客8J</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>是一道树上博弈与rmq结合的题目，其实不用rmq也行，很容易优化成线性的。</p>
<p>树上博弈，无非是两个人轮流走，递归搜索，走到每个位置的时候，会有多个选择，那么就递归选择最有利于自己的情况，这道题的部分看代码吧。</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ms=<span class="number">1000009</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[ms],to[ms],ne[ms];</span><br><span class="line"><span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,s,t;</span><br><span class="line"><span class="keyword">int</span> f[ms]; </span><br><span class="line"><span class="keyword">int</span> vis[ms];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;road;</span><br><span class="line"><span class="keyword">int</span> len[ms];</span><br><span class="line"><span class="keyword">int</span> st[<span class="number">3</span>][ms/<span class="number">2</span>][<span class="number">22</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[++tot]=y;</span><br><span class="line">    ne[tot]=head[x];</span><br><span class="line">    head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span><span class="comment">//得到一棵树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[u]=fa;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u]; i; i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=to[i];</span><br><span class="line">        <span class="keyword">if</span>(v!=fa) dfs(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getlen</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span><span class="comment">//得到s~t上每点可以到达的最大深度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u]; i; i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=to[i];</span><br><span class="line">        <span class="keyword">if</span>(v==fa || vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        ans=max(ans,getlen(v,u)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span><span class="comment">//rmq询问</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="built_in">log</span>(r-l+<span class="number">1</span>)/<span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(id==<span class="number">1</span>) <span class="keyword">return</span> max(st[<span class="number">1</span>][l][k],st[<span class="number">1</span>][r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> max(st[<span class="number">2</span>][l][k],st[<span class="number">2</span>][r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>)<span class="comment">//第一个人想让差值尽量大，是max</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> score=st[<span class="number">1</span>][l][<span class="number">0</span>]-query(<span class="number">2</span>,l+<span class="number">1</span>,r);<span class="comment">//他从第i个点离开时的得分</span></span><br><span class="line">        <span class="keyword">if</span>(l+<span class="number">1</span>==r) <span class="keyword">return</span> score;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> max(score,solve(l+<span class="number">1</span>,r,<span class="number">2</span>));<span class="comment">//不从第i个点离开，继续在s~t路经上走1步</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//第二个人想让差值尽量大，是min</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> score=query(<span class="number">1</span>,l,r<span class="number">-1</span>)-st[<span class="number">2</span>][r][<span class="number">0</span>];<span class="comment">//他从第i个点离开时的得分</span></span><br><span class="line">        <span class="keyword">if</span>(l+<span class="number">1</span>==r) <span class="keyword">return</span> score;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> min(score,solve(l,r<span class="number">-1</span>,<span class="number">1</span>));<span class="comment">//不从第i个点离开，继续在s~t路经上走1步</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;n,&amp;s,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        add(x,y);</span><br><span class="line">        add(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(s,<span class="number">0</span>);<span class="comment">//以s为根，建一棵树</span></span><br><span class="line">    <span class="keyword">while</span>(t)<span class="comment">//得到从s到t的路径</span></span><br><span class="line">    &#123;</span><br><span class="line">        road.push_back(t);</span><br><span class="line">        vis[t]=<span class="number">1</span>;<span class="comment">//表示这个点用过</span></span><br><span class="line">        t=f[t];</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(road.begin(),road.end());<span class="comment">//翻转一下方便我想</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;road.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        len[i+<span class="number">1</span>]=getlen(road[i],<span class="number">0</span>);<span class="comment">//s~t这条路径。得到以road[i]为根的子树的最大深度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l=road.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=l; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        st[<span class="number">1</span>][i][<span class="number">0</span>]=len[i]+i;<span class="comment">//这是从s出发，然后在i点离开s~t路径的深度</span></span><br><span class="line">        st[<span class="number">2</span>][i][<span class="number">0</span>]=len[i]+l-i+<span class="number">1</span>;<span class="comment">//这是从t出发，然后在i点离开s~t路径的深度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tt=<span class="built_in">log</span>(l)/<span class="built_in">log</span>(<span class="number">2</span>);<span class="comment">//rmq预处理区间最值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=tt; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i+(<span class="number">1</span>&lt;&lt;j)&lt;=l+<span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[<span class="number">1</span>][i][j]=max(st[<span class="number">1</span>][i][j<span class="number">-1</span>],st[<span class="number">1</span>][i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">            st[<span class="number">2</span>][i][j]=max(st[<span class="number">2</span>][i][j<span class="number">-1</span>],st[<span class="number">2</span>][i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,solve(<span class="number">1</span>,l,<span class="number">1</span>));<span class="comment">//递归搜索，树上博弈</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/01/26/Floyd%E5%8E%9F%E7%90%86/">Floyd原理</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-01-26</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-01-26</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
      
<p>floyd算法是一个经典的动态规划算法。用通俗的语言来描述的话，首先我们的目标是寻找从点i到点j的最短路径。从动态规划的角度看问题，我们需要为这个目标重新做一个诠释（这个诠释正是动态规划最富创造力的精华所在），floyd算法加入了这个概念。（来源于网络）</p>
<p>为什么说floyd是经典的dp？因为它暗含这个东西：Ak(i,j)</p>
<p>Ak(i,j)表示从i到j中途不经过索引比k大的点的最短路径。</p>
<p>在枚举到k的时候，其实已经得到了：前k-1个点的最短路径。</p>
<p>假设我们想要得到Ak(i,j)</p>
<p>Ak(i,j)，那么有两种情况，一种是Ak(i,j)沿途经过k点，另一种是不经过k点。对于前者来说，那么我们就可以以k为中间点得到 Ak−1(i,k)+Ak−1(k,j)，为什么是Ak−1？，因为对(i,k)和(k,j)来说，k本来就是源点和终点，满足不经过比k大的条件，所以就有了Ak−1。对于后者而言，那么就是Ak−1(i,j)</p>
<p>Ak−1(i,j)。所以递推式就是二者取min。</p>
<p>那么为什么k一定要放在最外层呢？</p>
<p>两句话解释一下：因为内两层是用来遍历i，j，而外层k才是用来递归i到j的路线。其实也就是，如果将k放到内部，那么每次更新的最短路都是假最短路，是更新不完全的，因为它没有借助其它路线的更新，只是简单地更新了一部分路线，就草草结束。</p>
<p><strong>贴一道牛客题目</strong></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/11258/J" >21牛客多校7J</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>题意：使用错误的floyd，还能有多少条路径是正确的最短路。</p>
<p>题解：有两种情况是在使用错误的情况下仍然正确的</p>
<p>1.原本i-&gt;j这条边就是最短路。</p>
<p>2.i-&gt;k和k-&gt;j属于都属于情况1，而且d[i,j]=d[i,k]+d[k,j]，那么i-&gt;j也有一条最短路，并且可以供接下来使用。</p>
<p>这题可以先处理出所有正确的最短路，先判断情况1，并且存下这些正确的最短路，然后使用floyd模拟错误情况下的过程，如果有情况2，则存下这条新的最短路，接下来还能使用，注意剪枝，因为边不多，所以很多情况可以被剪掉。详见代码。</p>

        <h1 id="源码"   >
          <a href="#源码" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#源码"></a> 源码</h1>
      
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ms=<span class="number">1000009</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    node(<span class="keyword">int</span> v=<span class="number">0</span>,<span class="keyword">int</span> w=<span class="number">0</span>):v(v),w(w)&#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;a,<span class="keyword">const</span> node &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.w&gt;b.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; e[<span class="number">2009</span>];</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">2009</span>][<span class="number">2008</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">2009</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ac[<span class="number">2009</span>];</span><br><span class="line"><span class="keyword">bool</span> vis1[<span class="number">2009</span>][<span class="number">2009</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">priority_queue</span>&lt;node&gt;q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij</span><span class="params">(<span class="keyword">int</span> s)</span><span class="comment">//得到正确的路径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dis[s][s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        vis[i]=<span class="number">0</span>;</span><br><span class="line">    q.push(&#123;s,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.top().v;</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:e[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v=i.v;</span><br><span class="line">            <span class="keyword">int</span> w=i.w;</span><br><span class="line">            <span class="keyword">if</span>(dis[s][v]&gt;dis[s][u]+w)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[s][v]=dis[s][u]+w;</span><br><span class="line">                q.push(&#123;v,dis[s][v]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:e[s])<span class="comment">//把正确路径中，符合第一种情况的边存下来，并且标记好</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[s][i.v]==i.w)</span><br><span class="line">        &#123;</span><br><span class="line">            vis1[s][i.v]=<span class="number">1</span>;</span><br><span class="line">            ac[s].push_back(i.v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">            dis[i][j]=inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        e[x].push_back(&#123;y,z&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        dij(i);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[i][j]==inf || i==j ||vis1[i][j])<span class="comment">//这三种情况属于已经是最短路了</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> k:ac[i])<span class="comment">//i-&gt;k-&gt;j是否存在一条最短路</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(vis1[k][j] &amp;&amp; dis[i][j]==dis[i][k]+dis[k][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    vis1[i][j]=<span class="number">1</span>;</span><br><span class="line">                    ac[i].push_back(j);<span class="comment">//根据错误的floyd，发现这条边是要加进去的，因为之后可能会用到</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/01/26/hexo%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E6%90%9C%E7%B4%A2%E5%92%8C%E8%AE%BF%E9%97%AE%E8%AE%A1%E6%95%B0%E5%8A%9F%E8%83%BD/">hexo添加本地搜索和访问计数功能</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-01-26</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-01-26</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="添加本地搜索和计数功能"   >
          <a href="#添加本地搜索和计数功能" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#添加本地搜索和计数功能"></a> <strong>添加本地搜索和计数功能</strong></h1>
      
<p>选了个小众的hexo主题，每次遇到问题都要自己摸索好久，唉。</p>

        <h2 id="本地搜索功能"   >
          <a href="#本地搜索功能" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#本地搜索功能"></a> 本地搜索功能</h2>
      

        <h2 id="安装本地搜索插件"   >
          <a href="#安装本地搜索插件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#安装本地搜索插件"></a> 安装本地搜索插件</h2>
      
<p>打开git，在根目录下：</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></div></figure>
<p>可以在根目录下的package.json查看是否安装成功。</p>

        <h2 id="修改根目录的配置文件"   >
          <a href="#修改根目录的配置文件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#修改根目录的配置文件"></a> 修改根目录的配置文件</h2>
      
<p>打开根目录的_config.yml，添加下面的内容，有的可能是search.json，根据需求修改。post表示搜索范围只包括文章。</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  content: <span class="literal">true</span></span><br></pre></td></tr></table></div></figure>
<p>我自己配置的时候，发现就是json我不能用，本地可以用，但是部署上去却失效了，给我恶心坏了，后来不知道改了什么东西，就莫名其妙能用了。。。</p>

        <h2 id="修改主题配置文件"   >
          <a href="#修改主题配置文件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#修改主题配置文件"></a> 修改主题配置文件</h2>
      
<p>打开主题目录下的_config.yml，将false改为true。</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: <span class="literal">true</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="优缺点"   >
          <a href="#优缺点" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#优缺点"></a> 优缺点</h2>
      
<ul>
<li>搜索次数无限制</li>
<li>支持多关键词搜素（在搜索框中，用空格将关键词隔开）</li>
<li>既能搜索文章标题，又能搜索文章内容</li>
<li>搜索速度快</li>
<li>但是当博客内容过多时，会出问题</li>
</ul>

        <h2 id="注"   >
          <a href="#注" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#注"></a> 注</h2>
      
<p>如果搜索内容失效，大概率是search.xml文件里的内容出问题了，这部分我也不会搞，毕竟不懂它的语法，可以百度试试。</p>

        <h2 id="访问计数"   >
          <a href="#访问计数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#访问计数"></a> 访问计数</h2>
      
<p>使用的是第三方插件：不蒜子，主要是免费，很多博客都用的这个，虽然有些缺陷，但是也勉强能用。</p>

        <h3 id="改主题配置文件"   >
          <a href="#改主题配置文件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#改主题配置文件"></a> 改主题配置文件</h3>
      
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">busuanzi:</span><br><span class="line"> enable: <span class="literal">true</span></span><br></pre></td></tr></table></div></figure>
<p>我这个主题只要修改这里就行了，但是有很多不足，具体我也不会改，之后再看。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/01/26/%E6%B7%BB%E5%8A%A0%E5%8F%8B%E9%93%BE/">添加友链</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-01-26</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-01-26</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="添加友链低配版"   >
          <a href="#添加友链低配版" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#添加友链低配版"></a> 添加友链(低配版)</h2>
      

        <h3 id="新增文件"   >
          <a href="#新增文件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#新增文件"></a> 新增文件</h3>
      
<p>在主目录下打开source，然后新建文件夹links，打开links，新建index，后缀为md。输入以下内容：</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 友链</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;post-body&quot;</span>&gt;</span><br><span class="line">   &lt;div id=<span class="string">&quot;links&quot;</span>&gt;</span><br><span class="line">      &lt;style&gt;</span><br><span class="line">         .links-content&#123;</span><br><span class="line">         margin-top:<span class="number">1</span>rem;</span><br><span class="line">         &#125;</span><br><span class="line">         .link-navigation::after &#123;</span><br><span class="line">         content: <span class="string">&quot; &quot;</span>;</span><br><span class="line">         display: block;</span><br><span class="line">         clear: both;</span><br><span class="line">         &#125;</span><br><span class="line">         .card &#123;</span><br><span class="line">         width: <span class="number">45</span>%;</span><br><span class="line">         font-size: <span class="number">1</span>rem;</span><br><span class="line">         padding: <span class="number">10</span>px <span class="number">20</span>px;</span><br><span class="line">         border-radius: <span class="number">4</span>px;</span><br><span class="line">         transition-duration: <span class="number">0.15</span>s;</span><br><span class="line">         margin-bottom: <span class="number">1</span>rem;</span><br><span class="line">         display:flex;</span><br><span class="line">         &#125;</span><br><span class="line">         .card:nth-child(odd) &#123;</span><br><span class="line">         <span class="keyword">float</span>: left;</span><br><span class="line">         &#125;</span><br><span class="line">         .card:nth-child(even) &#123;</span><br><span class="line">         <span class="keyword">float</span>: right;</span><br><span class="line">         &#125;</span><br><span class="line">         .card:hover &#123;</span><br><span class="line">         transform: scale(<span class="number">1.1</span>);</span><br><span class="line">         box-shadow: <span class="number">0</span> <span class="number">2</span>px <span class="number">6</span>px <span class="number">0</span> rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.12</span>), <span class="number">0</span> <span class="number">0</span> <span class="number">6</span>px <span class="number">0</span> rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.04</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         .card a &#123;</span><br><span class="line">         border:none;</span><br><span class="line">         &#125;</span><br><span class="line">         .card .ava &#123;</span><br><span class="line">         width: <span class="number">3</span>rem!important;</span><br><span class="line">         height: <span class="number">3</span>rem!important;</span><br><span class="line">         margin:<span class="number">0</span>!important;</span><br><span class="line">         margin-right: <span class="number">1</span>em!important;</span><br><span class="line">         border-radius:<span class="number">4</span>px;</span><br><span class="line">         &#125;</span><br><span class="line">         .card .card-header &#123;</span><br><span class="line">         font-style: italic;</span><br><span class="line">         overflow: hidden;</span><br><span class="line">         width: <span class="number">100</span>%;</span><br><span class="line">         &#125;</span><br><span class="line">         .card .card-header a &#123;</span><br><span class="line">         font-style: normal;</span><br><span class="line">         color: #<span class="number">2b</span>bc8a;</span><br><span class="line">         font-weight: bold;</span><br><span class="line">         text-decoration: none;</span><br><span class="line">         &#125;</span><br><span class="line">         .card .card-header a:hover &#123;</span><br><span class="line">         color: #d480aa;</span><br><span class="line">         text-decoration: none;</span><br><span class="line">         &#125;</span><br><span class="line">         .card .card-header .info &#123;</span><br><span class="line">         font-style:normal;</span><br><span class="line">         color:#a3a3a3;</span><br><span class="line">         font-size:<span class="number">14</span>px;</span><br><span class="line">         min-width: <span class="number">0</span>;</span><br><span class="line">         overflow: hidden;</span><br><span class="line">         white-space: nowrap;</span><br><span class="line">         &#125;</span><br><span class="line">      &lt;/style&gt;</span><br><span class="line">      &lt;div <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;links-content&quot;</span>&gt;</span><br><span class="line">         &lt;div <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;link-navigation&quot;</span>&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;card&quot;</span>&gt;</span><br><span class="line">               &lt;img <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;ava&quot;</span> src=<span class="string">&quot;图片地址&quot;</span> /&gt;</span><br><span class="line">               &lt;div class=<span class="string">&quot;card-header&quot;</span>&gt;</span><br><span class="line">                  &lt;div&gt;</span><br><span class="line">                     &lt;a href=<span class="string">&quot;博客链接&quot;</span>&gt;名称&lt;/a&gt;</span><br><span class="line">                  &lt;/div&gt;</span><br><span class="line">                  &lt;div class=<span class="string">&quot;info&quot;</span>&gt;描述&lt;/div&gt;</span><br><span class="line">               &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">         &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></div></figure>
<p>其实就是html语句，在页面上生成我们想要的内容，简单快捷，其实是不会修改pug文件的内容。</p>
<p>如果想要增加友链，复制以下内容即可：</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;card&quot;</span>&gt;</span><br><span class="line">   &lt;img <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;ava&quot;</span> src=<span class="string">&quot;图片地址&quot;</span> /&gt;</span><br><span class="line">   &lt;div class=<span class="string">&quot;card-header&quot;</span>&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">         &lt;a href=<span class="string">&quot;博客链接&quot;</span>&gt;名称&lt;/a&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div class=<span class="string">&quot;info&quot;</span>&gt;描述&lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></div></figure>

        <h3 id="修改主题配置文件"   >
          <a href="#修改主题配置文件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#修改主题配置文件"></a> 修改主题配置文件</h3>
      
<p>打开主题文件下的_config_yml文件，添加下列语句：</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || fas fa-home</span><br><span class="line">  archives: /archives/ || fas fa-folder-open</span><br><span class="line">  categories: /categories/ || fas fa-layer-group</span><br><span class="line">  tags: /tags/ || fas fa-tags</span><br><span class="line">  # You can add a secondary menu like follow.</span><br><span class="line">  # xxx1: javascript:; || fa(s|r|l|d|b) fa-xxx</span><br><span class="line">  # 在这个menu下面添加这一行东西</span><br><span class="line">  links: /links/ || fas fa-link</span><br></pre></td></tr></table></div></figure>

        <h3 id="修改翻译文件"   >
          <a href="#修改翻译文件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#修改翻译文件"></a> 修改翻译文件</h3>
      
<p>进入\themes\stun\languages中打开zh-CH_yml，找到menu，添加这一行内容：</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">links: 友链</span><br></pre></td></tr></table></div></figure></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/01/26/%E6%A0%91%E4%B8%8Adfs%E5%BA%8F/">树上dfs序</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-01-26</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-01-26</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
      
<p>定义两个数组，dfn[x]，edn[x]。dfs从根结点开始，每个结点分别记录两个信息：dfn[x]，edn[x]，dfn[x]为dfs进入结点x时的时间戳，end[x]为dfs离开结点x时的时间戳。</p>
<p>dfs序可以把一棵树区间化，即可以求出每个节点的管辖区间。对于一棵树的dfs序而言，同一棵子树所对应的一定是dfs序中连续的一段。很方便之后的区间操作。</p>
<p>如下图：</p>
<p><img src="%E5%9B%BE1.png" alt="图1" /></p>
<p>形成的ｄｆｓ序：</p>
<p><img src="%E5%9B%BE2.png" alt="图2" /></p>

        <h1 id="源码"   >
          <a href="#源码" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#源码"></a> 源码</h1>
      
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfsn</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    dfn[u]=cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:e2[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfsn(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    edn[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>放一道牛客多校的题目：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/11258/F" >21牛客多校7F</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>这道题用到了ｄｆｓ序、树上滑动窗口、线段树。</p>
<p>题意：两棵树，点数一样，现在选出一个点集，使得点集中点的点在树1中是连通的，且对于任意两点，一点必是另一点的祖先；对于树2，则不能是另一方的祖先。输出点集中最多有几个点。</p>
<p>题解：两棵树不同，所以要分别进行处理。很明显，对于条件2，一方不能作为另一方的祖先，那它们一定不在通一棵子树下，这点我们可以使用dfs序，如果两个点的时间有重合，那么明显不能满足条件2，这个可以用dfs序+线段树维护。而对于第一棵树，连通且有祖先关系，这样明显是一条链，最暴力的情况我们可以枚举每一条链，但这必超时啊，所以就妙妙妙，我们可以用滑动窗口维护这条链。  当加入一个新的点，如果违法，则可以删掉首节点，然后接着搜，搜完之后再回溯。这样做的正确性，其实是因为当删掉了最上面的点，其实它已经被使用过了，不是当前较优的选择，而且如果出现更长的链，也不会是包含它的，这样选择可以大大降低复杂度，接近O(N)，在树上优美地滑着走。如果不违法，则加进点集，更新结果。</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs rt&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ms=<span class="number">3e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,cnt,ans;</span><br><span class="line"><span class="keyword">int</span> edn[ms],dfn[ms],way[ms],vis[ms],dp[ms];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;e1[ms],e2[ms];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,f,inc;</span><br><span class="line">&#125;p[ms&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p[rt].l=l;</span><br><span class="line">    p[rt].r=r;</span><br><span class="line">    p[rt].f=p[rt].inc=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(ls,l,mid); build(rs,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p[rt].f=max(p[ls].f,p[rs].f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[rt].inc)</span><br><span class="line">    &#123;</span><br><span class="line">        p[ls].f+=p[rt].inc;</span><br><span class="line">        p[rs].f+=p[rt].inc;</span><br><span class="line">        p[ls].inc+=p[rt].inc;</span><br><span class="line">        p[rs].inc+=p[rt].inc;</span><br><span class="line">        p[rt].inc=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[rt].l&gt;=l &amp;&amp; p[rt].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        p[rt].f+=val;</span><br><span class="line">        p[rt].inc+=val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(rt);</span><br><span class="line">    <span class="keyword">int</span> mid=(p[rt].l+p[rt].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) update(ls,l,r,val);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) update(rs,l,r,val);</span><br><span class="line">    push_up(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[rt].l&gt;=l &amp;&amp; p[rt].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> p[rt].f;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(rt);</span><br><span class="line">    <span class="keyword">int</span> mid=p[rt].l+p[rt].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) res=max(res,query(ls,l,r));</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) res=max(res,query(rs,l,r));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// struct node&#123;</span></span><br><span class="line"><span class="comment">//     int l,r,f,inc;</span></span><br><span class="line"><span class="comment">// &#125;segtree[ms&lt;&lt;2];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void pushup(int x)&#123;segtree[x].f=max(segtree[x&lt;&lt;1].f,segtree[x&lt;&lt;1|1].f);&#125;//取较大者返回,我们需要的是判断是否有重复染色</span></span><br><span class="line"><span class="comment">// void pushdown(int x)&#123;//将懒惰标记往下传递</span></span><br><span class="line"><span class="comment">//     segtree[x&lt;&lt;1].f+=segtree[x].inc;</span></span><br><span class="line"><span class="comment">//     segtree[x&lt;&lt;1|1].f+=segtree[x].inc;</span></span><br><span class="line"><span class="comment">//     segtree[x&lt;&lt;1].inc+=segtree[x].inc;</span></span><br><span class="line"><span class="comment">//     segtree[x&lt;&lt;1|1].inc+=segtree[x].inc;</span></span><br><span class="line"><span class="comment">//     segtree[x].inc=0;//清空</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// void build(int x,int l,int r)&#123;//建树</span></span><br><span class="line"><span class="comment">//     segtree[x].l=l,segtree[x].r=r,segtree[x].f=segtree[x].inc=0;//初始化</span></span><br><span class="line"><span class="comment">//     if(l==r)return;</span></span><br><span class="line"><span class="comment">//     int mid=l+r&gt;&gt;1;</span></span><br><span class="line"><span class="comment">//     build(x&lt;&lt;1,l,mid);</span></span><br><span class="line"><span class="comment">//     build(x&lt;&lt;1|1,mid+1,r);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// void update(int x,int l,int r,int inc)&#123;</span></span><br><span class="line"><span class="comment">//     if(segtree[x].l==l&amp;&amp;segtree[x].r==r)&#123;</span></span><br><span class="line"><span class="comment">//         segtree[x].f+=inc;</span></span><br><span class="line"><span class="comment">//         segtree[x].inc+=inc;//标记</span></span><br><span class="line"><span class="comment">//         return;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     if(segtree[x].inc)pushdown(x);//下传标记</span></span><br><span class="line"><span class="comment">//     int mid=segtree[x].l+segtree[x].r&gt;&gt;1;</span></span><br><span class="line"><span class="comment">//     if(r&lt;=mid)update(x&lt;&lt;1,l,r,inc);</span></span><br><span class="line"><span class="comment">//     else if(l&gt;mid)update(x&lt;&lt;1|1,l,r,inc);</span></span><br><span class="line"><span class="comment">//     else update(x&lt;&lt;1,l,mid,inc),update(x&lt;&lt;1|1,mid+1,r,inc);</span></span><br><span class="line"><span class="comment">//     pushup(x);//更新</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int query(int x,int l,int r)&#123;//询问</span></span><br><span class="line"><span class="comment">//     if(segtree[x].l==l&amp;&amp;segtree[x].r==r)&#123;</span></span><br><span class="line"><span class="comment">//         return segtree[x].f;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     if(segtree[x].inc)pushdown(x);//下传标记</span></span><br><span class="line"><span class="comment">//     int mid=segtree[x].l+segtree[x].r&gt;&gt;1;</span></span><br><span class="line"><span class="comment">//     if(r&lt;=mid)return query(x&lt;&lt;1,l,r);</span></span><br><span class="line"><span class="comment">//     else if(l&gt;mid)return query(x&lt;&lt;1|1,l,r);</span></span><br><span class="line"><span class="comment">//     else return max(query(x&lt;&lt;1,l,mid),query(x&lt;&lt;1|1,mid+1,r));</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfsn</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    dfn[u]=cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:e2[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfsn(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    edn[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa,<span class="keyword">int</span> anc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    update(<span class="number">1</span>,dfn[u],edn[u],<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> tmp=query(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">if</span>(tmp&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[u]=dp[fa];</span><br><span class="line">        update(<span class="number">1</span>,dfn[anc],edn[anc],<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:e1[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">            way[u]=v;</span><br><span class="line">            dfs(v,u,way[anc]);</span><br><span class="line">        &#125;</span><br><span class="line">        update(<span class="number">1</span>,dfn[u],edn[u],<span class="number">-1</span>);</span><br><span class="line">        update(<span class="number">1</span>,dfn[anc],edn[anc],<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        dp[u]=dp[fa]+<span class="number">1</span>;</span><br><span class="line">        ans=max(ans,dp[u]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:e1[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">            way[u]=v;</span><br><span class="line">            dfs(v,u,anc);</span><br><span class="line">        &#125;</span><br><span class="line">        update(<span class="number">1</span>,dfn[u],edn[u],<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        e1[i].clear();</span><br><span class="line">        e2[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    way[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u,v;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">            e1[u].push_back(v);</span><br><span class="line">            e1[v].push_back(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u,v;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">            e2[u].push_back(v);</span><br><span class="line">            e2[v].push_back(u);</span><br><span class="line">        &#125;</span><br><span class="line">        build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        dfsn(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        dfs(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/01/26/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/">树上启发式合并</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-01-26</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-01-26</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
      
<p>启发式是一种思想。</p>
<p>启发式，顾名思义，就是从一些特性获得启发，然后来对算法进行优化，从而达到降低复杂度的效果。</p>
<p>就如A*算法和并查集按秩合并。就是启发式算法。</p>
<p>这里要说一种常见的启发式合并，即dsu on tree。（但是它和按秩合并有着很大区别，按秩是按树的高度）</p>
<p>dsu就是并查集的意思。</p>
<p>假如现由N个集合，M个元素分布在这N个集合中，我们通过什么操作来讲这N个集合合并到一起？</p>
<p>最坏的情况，第一个集合就有M元素，然后与其它空集分别合并，在合并时，我们又是采取将大集合并入小集合的操作，这样复杂度达到O（NM）。</p>
<p>启发式合并可以如何操作呢？</p>
<p>简单，我们每次将小集合并入大集合即可，那么合并之后的集合中元素数量必是小集合的两倍或以上，这样复杂度就降为O（logN）。这就是它的基本思想。</p>
<p>树上启发式合并，就是在树上采取这个操作。这里就结合一道题来看看。<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/600/E" >CF600E</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>可以看看这位大佬的讲解，很详细。<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://space.bilibili.com/120174936?spm_id_from=333.788.b_765f7570696e666f.1" >不分解的AgOH</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h1 id="源码"   >
          <a href="#源码" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#源码"></a> 源码</h1>
      
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ms=<span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">ll p[ms&lt;&lt;<span class="number">2</span>];</span><br><span class="line">ll n,m;</span><br><span class="line">ll la[ms&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (l&lt;=r)&amp;&amp;(L&lt;=l)&amp;&amp;(r&lt;=R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p[rt]=p[rt&lt;&lt;<span class="number">1</span>]+p[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(la[rt])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        p[rt&lt;&lt;<span class="number">1</span>]+=la[rt]*(m-l+<span class="number">1</span>);<span class="comment">//更新左子区间</span></span><br><span class="line">        p[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=la[rt]*(r-m);<span class="comment">//更新右子区间</span></span><br><span class="line">        la[rt&lt;&lt;<span class="number">1</span>]+=la[rt];<span class="comment">//下传标记</span></span><br><span class="line">        la[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=la[rt];</span><br><span class="line">        la[rt]=<span class="number">0</span>;<span class="comment">//取消标记</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt,ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(in(L,l,r,R))<span class="comment">//若L，R覆盖了当前的区间，那么更新一下，并且标记</span></span><br><span class="line">    &#123;</span><br><span class="line">        p[rt]+=(r-l+<span class="number">1</span>)*val;</span><br><span class="line">        la[rt]+=val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(rt,l,r);<span class="comment">//下传标记</span></span><br><span class="line">    <span class="keyword">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;=L) update(L,R,l,m,rt&lt;&lt;<span class="number">1</span>,val);<span class="comment">//递归更新</span></span><br><span class="line">    <span class="keyword">if</span>(m&lt;R) update(L,R,m+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,val);</span><br><span class="line">    push_up(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(in(L,l,r,R))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> p[rt];</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(rt,l,r);</span><br><span class="line">    ll cc=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;=L) cc+=getsum(L,R,l,m,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(m&lt;R) cc+=getsum(L,R,m+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> cc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll x;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        update(i,i,<span class="number">1</span>,n,<span class="number">1</span>,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> c,l,r;</span><br><span class="line">        ll d;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;c;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r&gt;&gt;d;</span><br><span class="line">            update(l,r,<span class="number">1</span>,n,<span class="number">1</span>,d);<span class="comment">//更新，l，r表示要更新的区间。1，n表示当前的区间。1是表示当前的区间编号，d是要更新的val</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">            ll ans=getsum(l,r,<span class="number">1</span>,n,<span class="number">1</span>);<span class="comment">//同上</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/01/26/%E7%BD%91%E7%BB%9C%E6%B5%81/">网络流</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-01-26</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-01-26</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
      
<p>提到图论，网络流是绝不能被忽视的东西，这方面我也得多练额，有些套路题现在还搞不出来。</p>
<p>涉及到网络流，有一个要引入的新概念：残量网络。</p>
<p>残量网络其实就是除去当前的流量以外，在网络中仍然剩余的流量。</p>
<p>另外，网络流中还会定义一个流函数f(x,y)，容量c(x,y)。前者表示当前边的流量，后者表示当前边的容量。</p>
<p>流函数有三个性质：</p>
<p>1.容量限制，即f(x,y)&lt;=c(x,y)</p>
<p>2.斜对称，f(x,y)=-f(y,x)</p>
<p>3.流量守恒，从源点到汇点的流量一样</p>
<p>注意，每条边都会定义一条反向边，反向边有一个≤0的流量，同时反向边的容量为0，c(y,x)=0。f(y,x)=c(y,x)-f(x,y)。（加入反向边意义是重大的）</p>
<p>最大流=最小割。</p>
<p>最大流可以用来解决二分图匹配问题。</p>
<p>常用的最大流算法有：Edmonds-Karp算法和dinic算法。</p>

        <h1 id="源码"   >
          <a href="#源码" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#源码"></a> 源码</h1>
      

        <h2 id="edmonds-karp算法"   >
          <a href="#edmonds-karp算法" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#edmonds-karp算法"></a> Edmonds-Karp算法</h2>
      
<p>思想就是不断用bfs寻找增广路，直到网络上不存在增广路为止。</p>
<p>每找到一套增广路就立刻增广。</p>
<p>复杂度O(nm^2)，实际上效率挺高，可以处理1e3~1e4的网络。</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> head[N],to[ms],ne[ms],cap[ms],vis[N],<span class="comment">/*当前增广路最小容量*/</span>incf[N],pre[N];<span class="comment">//记录前驱</span></span><br><span class="line"><span class="keyword">int</span> n,m,s,t,tot,maxflow;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[++tot]=v; cap[tot]=c; ne[tot]=head[u]; head[u]=tot;</span><br><span class="line">    to[++tot]=u; cap[tot]=<span class="number">0</span>; ne[tot]=head[v]; head[v]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">        vis[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    q.push(s); vis[s]=<span class="number">1</span>;</span><br><span class="line">    incf[s]=inf;<span class="comment">//增广路上各边的最小剩余容量</span></span><br><span class="line">    <span class="keyword">while</span>(q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u]; i; i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v=to[i];</span><br><span class="line">            <span class="keyword">if</span>(cap[i] &amp;&amp; !vis[v])<span class="comment">//可以增广</span></span><br><span class="line">            &#123;</span><br><span class="line">                incf[v]=min(incf[u],cap[i]);</span><br><span class="line">                pre[v]=i;<span class="comment">//记录前驱，可找增广路，便于找到最长路</span></span><br><span class="line">                q.push(v);</span><br><span class="line">                vis[v]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(v==t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=t;</span><br><span class="line">    <span class="keyword">while</span>(u!=s)<span class="comment">//更新增广路及其反向边剩余流量</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i=pre[u];</span><br><span class="line">        cap[i]-=incf[t];</span><br><span class="line">        cap[i^<span class="number">1</span>]+=incf[t];</span><br><span class="line">        u=to[i^<span class="number">1</span>];<span class="comment">//这条边的另一个端点</span></span><br><span class="line">    &#125;</span><br><span class="line">    maxflow+=incf[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tot=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">        head[i]=<span class="number">0</span>;</span><br><span class="line">    s=u; t=v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

        <h2 id="dinic算法"   >
          <a href="#dinic算法" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#dinic算法"></a> dinic算法</h2>
      
<p>EK算法由于每次只找一条增广路，每轮都可能遍历整个残量网络，效率低，可以进一步优化。</p>
<p>所以我们可以引入分层图思想，分层图明显是一个有向无环图。</p>
<p>重复以下步骤：</p>
<p>1.在残量网络bfs，构造分层图。</p>
<p>2.在分层图找增广路，回溯时更新剩余流量，每个点可以流向多条出边。</p>
<p>加入了部分优化。</p>
<p>复杂度O(n^2m)，可处理1e4~1e5的网络，对于二分图最大匹配可达O(m根号n)，实际更快。</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> head[N],to[ms],ne[ms],cap[ms],d[N],now[N];<span class="comment">//当前弧优化</span></span><br><span class="line"><span class="keyword">int</span> n,m,s,t,tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[++tot]=v; cap[tot]=c; ne[tot]=head[u]; head[u]=tot;</span><br><span class="line">    to[++tot]=u; cap[tot]=<span class="number">0</span>; ne[tot]=head[v]; head[v]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">        d[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    q.push(s); d[s]=<span class="number">1</span>; now[s]=head[s];<span class="comment">//当前弧优化</span></span><br><span class="line">    <span class="keyword">while</span>(q.size())<span class="comment">//构造分层图</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u]; i; i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v=to[i];</span><br><span class="line">            <span class="keyword">if</span>(cap[i] &amp;&amp; !d[v])</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(v);</span><br><span class="line">                now[v]=head[v];</span><br><span class="line">                d[v]=d[u]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(v==t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==t) <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="keyword">int</span> rest=flow,k,i;</span><br><span class="line">    <span class="keyword">for</span>(i=now[u]; i&amp;&amp;rest; i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=to[i];</span><br><span class="line">        <span class="keyword">if</span>(cap[i] &amp;&amp; d[v]==d[u]+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            k=dinic(v,min(rest,cap[i]));</span><br><span class="line">            <span class="keyword">if</span>(!k) d[v]=<span class="number">0</span>; <span class="comment">//剪枝，当前点已增广完毕</span></span><br><span class="line">            cap[i]-=k;</span><br><span class="line">            cap[i^<span class="number">1</span>]+=k;</span><br><span class="line">            rest-=k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    now[u]=i;<span class="comment">//当前弧优化，避免重复遍历从u出发不可扩展的边</span></span><br><span class="line">    <span class="keyword">return</span> flow-rest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">net</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxflow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> flow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs())</span><br><span class="line">        <span class="keyword">while</span>(flow=dinic(s,inf)) maxflow+=flow;</span><br><span class="line">    <span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tot=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">        head[i]=<span class="number">0</span>;</span><br><span class="line">    s=u; t=v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/01/26/KM%E6%A8%A1%E6%9D%BF/">KM模板</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-01-26</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-01-26</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
      
<p>大概分四步，具体思想和原理建议去百度搜一搜。</p>
<p>1、初始化可行标杆<br />
2、用匈牙利算法寻找完备匹配<br />
3、若未找到完备匹配则修改可行标杆<br />
4、重复（2）（3）直到找到相等子图的完备匹配</p>
<p>求二分图最大权匹配。要求最大权匹配必须是完备匹配（所有点用上）。</p>

        <h1 id="源码"   >
          <a href="#源码" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#源码"></a> 源码</h1>
      

        <h2 id="on4的dfs版本"   >
          <a href="#on4的dfs版本" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#on4的dfs版本"></a> O(n^4)的dfs版本：</h2>
      
<p>（若是随机数据，可以达到O(n^3)）</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 303</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line">ll w[N][N];</span><br><span class="line">ll la[N],lb[N];<span class="comment">//左右部点的顶标</span></span><br><span class="line"><span class="keyword">bool</span> va[N],vb[N];<span class="comment">//访问标记，是否在交错树中</span></span><br><span class="line"><span class="keyword">int</span> match[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll delta,upd[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va[x]=<span class="number">1</span>;<span class="comment">//x在交错树</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">1</span>; y&lt;=n; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vb[y]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(la[x]+lb[y]==w[x][y])<span class="comment">//相等子图</span></span><br><span class="line">        &#123;</span><br><span class="line">            vb[y]=<span class="number">1</span>;<span class="comment">//y在交错树</span></span><br><span class="line">            <span class="keyword">if</span>(!match[y] || dfs(match[y]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[y]=x;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> upd[y]=min(upd[y],la[x]+lb[y]-w[x][y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">km</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(match,<span class="number">0</span>,<span class="keyword">sizeof</span>(match));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        la[i]=-inf;</span><br><span class="line">        lb[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            la[i]=max(la[i],w[i][j]);<span class="comment">//建议换位大小比较，不用max和min函数。因为当复杂度高时，常数大，是O（2）的。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++) upd[j]= inf;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//直到左部点找到匹配</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(va,<span class="number">0</span>,<span class="keyword">sizeof</span>(va));</span><br><span class="line">            <span class="built_in">memset</span>(vb,<span class="number">0</span>,<span class="keyword">sizeof</span>(vb));</span><br><span class="line">            <span class="keyword">if</span>(dfs(i)) <span class="keyword">break</span>;</span><br><span class="line">            delta= <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">                <span class="keyword">if</span>(!vb[j]) delta=min(delta,upd[j]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)<span class="comment">//修改顶标</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(va[j]) la[j]-=delta;</span><br><span class="line">                <span class="keyword">if</span>(vb[j]) lb[j]+=delta;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) ans+=w[match[i]][i];<span class="comment">//是inf则说明未完备匹配</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

        <h2 id="on3的bfs版本"   >
          <a href="#on3的bfs版本" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#on3的bfs版本"></a> O(n^3)的bfs版本</h2>
      
<p>其实本质一样，只是不会再从头搜而已。</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">ll w[N][N];</span><br><span class="line">ll la[N],lb[N];<span class="comment">//左右部点的顶标</span></span><br><span class="line"><span class="keyword">bool</span> va[N],vb[N];<span class="comment">//访问标记，是否在交错树中</span></span><br><span class="line"><span class="keyword">int</span> match[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll delta,upd[N];</span><br><span class="line"><span class="keyword">int</span> p[N];<span class="comment">//交错树</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,v=<span class="number">0</span>,vv=<span class="number">0</span>;<span class="comment">//最开始0匹配u</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i]=<span class="number">0</span>;upd[i]=inf;</span><br><span class="line">    &#125;</span><br><span class="line">    match[v]=u;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        a=match[v];<span class="comment">//现在是帮a找完美匹配 </span></span><br><span class="line">        delta=inf;</span><br><span class="line">        vb[v]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> b=<span class="number">1</span>; b&lt;=n; b++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vb[b]) <span class="keyword">continue</span>;<span class="comment">//本次访问过,不用管了 </span></span><br><span class="line">            <span class="keyword">if</span>(upd[b]&gt;la[a]+lb[b]-w[a][b])</span><br><span class="line">            &#123;</span><br><span class="line">                upd[b]=la[a]+lb[b]-w[a][b];<span class="comment">//查找与b相邻的边，找出b的最小误差</span></span><br><span class="line">                p[b]=v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(upd[b]&lt;delta)</span><br><span class="line">            &#123;</span><br><span class="line">                delta=upd[b];</span><br><span class="line">                vv=b;<span class="comment">//vv记录谁是最小误差</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//delta是最小的误差,用于调整期望 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> b=<span class="number">0</span>; b&lt;=n; b++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vb[b])</span><br><span class="line">            &#123;</span><br><span class="line">                la[match[b]]-=delta;</span><br><span class="line">                lb[b]+=delta;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> upd[b]-=delta;</span><br><span class="line">        &#125;</span><br><span class="line">        v=vv;<span class="comment">//vv记录的是最小误差,那么现在修改了期望值,所以可以直接匹配v</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(match[v]);<span class="comment">//直到找到一个人没有匹配 </span></span><br><span class="line">    <span class="keyword">while</span>(v)</span><br><span class="line">    &#123;</span><br><span class="line">        match[v]=match[p[v]];</span><br><span class="line">        v=p[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">km</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        match[i]=la[i]=lb[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vb,<span class="number">0</span>,<span class="keyword">sizeof</span>(vb));</span><br><span class="line">        bfs(i);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) ans+=w[match[i]][i];<span class="comment">//是inf则说明未完备匹配</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/01/26/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E6%A8%A1%E6%9D%BF/">后缀数组模板</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-01-26</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-01-26</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
      
<p>处理字符串的强力工具，一种常用的后缀数据结构（另外还有SAM后缀自动机、后缀树）。</p>
<p>可以看看凯巨的讲解，很清楚：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV177411P7KS" >后缀数组</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>常用的DA模板，O（nlogn），代码短。</p>
<p>复杂的DC3模板，O（n），码量大，注意开3倍空间。</p>
<p>下面只贴DA模板，来自罗穗骞大佬。</p>
<p>把 s 的每个后缀按照字典序排序，</p>
<p>后缀数组 sa[i] 就表示排名为 i 的后缀的起始位置的下标</p>
<p>而它的映射数组 rak[i] 就表示起始位置的下标为 i 的后缀的排名</p>
<p>简单来说， sa[i] 表示排名为 i 的是啥， rak[i] 表示第 i 个的排名是啥</p>
<p>LCP ：</p>
<p>LCP(i,j) 表示 suf(sa[i]) 与 suf(sa[j]) 的最长公共前缀</p>
<p>LCP(i,j)=LCP(j,i);</p>
<p>LCP(i,i)=len(sa[i])=n-sa[i]+1;</p>
<p>Height[i] 表示 LCP(i,i-1)</p>

        <h1 id="源码"   >
          <a href="#源码" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#源码"></a> 源码</h1>
      
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注释版</span></span><br><span class="line"><span class="keyword">int</span> wa[maxn],wb[maxn],wv[maxn],ws[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;  <span class="comment">//就像论文所说，由于末尾填了0，所以如果r[a]==r[b]（实际是y[a]==y[b]），说明待合并的两个长为j的字符串，前面那个一定不包含末尾0，因而后面这个的起始位置至多在0的位置，不会再靠后了，因而不会产生数组越界。</span></span><br><span class="line"><span class="comment">//da函数的参数n代表字符串中字符的个数，这里的n里面是包括人为在字符串末尾添加的那个0的，但论文的图示上并没有画出字符串末尾的0。</span></span><br><span class="line"><span class="comment">//da函数的参数m代表字符串中字符的取值范围，是基数排序的一个参数，如果原序列都是字母可以直接取128，如果原序列本身都是整数的话，则m可以取比最大的整数大1的值。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> *sa,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,p,*x=wa,*y=wb,*t;</span><br><span class="line">    <span class="comment">//以下四行代码是把各个字符（也即长度为1的字符串）进行基数排序，如果不理解为什么这样可以达到基数排序的效果，不妨自己实际用纸笔模拟一下，我最初也是这样才理解的。</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++) ws[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) ws[x[i]=r[i]]++;  <span class="comment">//x[]里面本意是保存各个后缀的rank值的，但是这里并没有去存储rank值，因为后续只是涉及x[]的比较工作，因而这一步可以不用存储真实的rank值，能够反映相对的大小即可。</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++) ws[i]+=ws[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--ws[x[i]]]=i;  <span class="comment">//i之所以从n-1开始循环，是为了保证在当字符串中有相等的字符串时，默认靠前的字符串更小一些。</span></span><br><span class="line">    <span class="comment">//下面这层循环中p代表rank值不用的字符串的数量，如果p达到n，那么各个字符串的大小关系就已经明了了。</span></span><br><span class="line">    <span class="comment">//j代表当前待合并的字符串的长度，每次将两个长度为j的字符串合并成一个长度为2*j的字符串，当然如果包含字符串末尾具体则数值应另当别论，但思想是一样的。</span></span><br><span class="line">    <span class="comment">//m同样代表基数排序的元素的取值范围</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j*=<span class="number">2</span>,m=p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//以下两行代码实现了对第二关键字的排序</span></span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;i++) y[p++]=i;  <span class="comment">//结合论文的插图，我们可以看到位置在第n-j至n的元素的第二关键字都为0，因此如果按第二关键字排序，必然这些元素都是排在前面的。</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(sa[i]&gt;=j) y[p++]=sa[i]-j;  <span class="comment">//结合论文的插图，我们可以看到，下面一行的第二关键字不为0的部分都是根据上面一行的排序结果得到的，且上一行中只有sa[i]&gt;=j的第sa[i]个字符串（这里以及后面指的“第?个字符串”不是按字典序排名来的，是按照首字符在字符串中的位置来的）的rank才会作为下一行的第sa[i]-j个字符串的第二关键字，而且显然按sa[i]的顺序rank[sa[i]]是递增的，因此完成了对剩余的元素的第二关键字的排序。</span></span><br><span class="line">        <span class="comment">//第二关键字基数排序完成后，y[]里存放的是按第二关键字排序的字符串下标</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) wv[i]=x[y[i]];  <span class="comment">//这里相当于提取出每个字符串的第一关键字（前面说过了x[]是保存rank值的，也就是字符串的第一关键字），放到wv[]里面是方便后面的使用</span></span><br><span class="line">        <span class="comment">//以下四行代码是按第一关键字进行的基数排序</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++) ws[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) ws[wv[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++) ws[i]+=ws[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--ws[wv[i]]]=y[i];  <span class="comment">//i之所以从n-1开始循环，含义同上，同时注意这里是y[i]，因为y[i]里面才存着字符串的下标</span></span><br><span class="line">        <span class="comment">//下面两行就是计算合并之后的rank值了，而合并之后的rank值应该存在x[]里面，但我们计算的时候又必须用到上一层的rank值，也就是现在x[]里面放的东西，如果我既要从x[]里面拿，又要向x[]里面放，怎么办？当然是先把x[]的东西放到另外一个数组里面，省得乱了。这里就是用交换指针的方式，高效实现了将x[]的东西“复制”到了y[]中。</span></span><br><span class="line">        <span class="keyword">for</span>(t=x,x=y,y=t,p=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        x[sa[i]]=cmp(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++; <span class="comment">//这里就是用x[]存储计算出的各字符串rank的值了，记得我们前面说过，计算sa[]值的时候如果字符串相同是默认前面的更小的，但这里计算rank的时候必须将相同的字符串看作有相同的rank，要不然p==n之后就不会再循环啦。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//能够线性计算height[]的值的关键在于h[](height[rank[]])的性质，即h[i]&gt;=h[i-1]-1，下面具体分析一下这个不等式的由来。</span></span><br><span class="line"><span class="comment">//论文里面证明的部分一开始看得我云里雾里，后来画了一下终于搞明白了，我们先把要证什么放在这：对于第i个后缀，设j=sa[rank[i] - 1]，也就是说j是i的按排名来的上一个字符串，按定义来i和j的最长公共前缀就是height[rank[i]]，我们现在就是想知道height[rank[i]]至少是多少，而我们要证明的就是至少是height[rank[i-1]]-1。</span></span><br><span class="line"><span class="comment">//好啦，现在开始证吧。</span></span><br><span class="line"><span class="comment">//首先我们不妨设第i-1个字符串（这里以及后面指的“第?个字符串”不是按字典序排名来的，是按照首字符在字符串中的位置来的）按字典序排名来的前面的那个字符串是第k个字符串，注意k不一定是i-2，因为第k个字符串是按字典序排名来的i-1前面那个，并不是指在原字符串中位置在i-1前面的那个第i-2个字符串。</span></span><br><span class="line"><span class="comment">//这时，依据height[]的定义，第k个字符串和第i-1个字符串的公共前缀自然是height[rank[i-1]]，现在先讨论一下第k+1个字符串和第i个字符串的关系。</span></span><br><span class="line"><span class="comment">//第一种情况，第k个字符串和第i-1个字符串的首字符不同，那么第k+1个字符串的排名既可能在i的前面，也可能在i的后面，但没有关系，因为height[rank[i-1]]就是0了呀，那么无论height[rank[i]]是多少都会有height[rank[i]]&gt;=height[rank[i-1]]-1，也就是h[i]&gt;=h[i-1]-1。</span></span><br><span class="line"><span class="comment">//第二种情况，第k个字符串和第i-1个字符串的首字符相同，那么由于第k+1个字符串就是第k个字符串去掉首字符得到的，第i个字符串也是第i-1个字符串去掉首字符得到的，那么显然第k+1个字符串要排在第i个字符串前面，要么就产生矛盾了。同时，第k个字符串和第i-1个字符串的最长公共前缀是height[rank[i-1]]，那么自然第k+1个字符串和第i个字符串的最长公共前缀就是height[rank[i-1]]-1。</span></span><br><span class="line"><span class="comment">//到此为止，第二种情况的证明还没有完，我们可以试想一下，对于比第i个字符串的字典序排名更靠前的那些字符串，谁和第i个字符串的相似度最高（这里说的相似度是指最长公共前缀的长度）？显然是排名紧邻第i个字符串的那个字符串了呀，即sa[rank[i]-1]。也就是说sa[rank[i]]和sa[rank[i]-1]的最长公共前缀至少是height[rank[i-1]]-1，那么就有height[rank[i]]&gt;=height[rank[i-1]]-1，也即h[i]&gt;=h[i-1]-1。</span></span><br><span class="line"><span class="comment">//证明完这些之后，下面的代码也就比较容易看懂了。</span></span><br><span class="line"><span class="keyword">int</span> rank[maxn],height[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calheight</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> *sa,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) rank[sa[i]]=i;  <span class="comment">//计算每个字符串的字典序排名</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;height[rank[i++]]=k)  <span class="comment">//将计算出来的height[rank[i]]的值，也就是k，赋给height[rank[i]]。i是由0循环到n-1，但实际上height[]计算的顺序是由height[rank[0]]计算到height[rank[n-1]]。</span></span><br><span class="line">    <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rank[i]<span class="number">-1</span>];r[i+k]==r[j+k];k++);  <span class="comment">//上一次的计算结果是k，首先判断一下如果k是0的话，那么k就不用动了，从首字符开始看第i个字符串和第j个字符串前面有多少是相同的，如果k不为0，按我们前面证明的，最长公共前缀的长度至少是k-1，于是从首字符后面k-1个字符开始检查起即可。</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后再说明一点，就是关于da和calheight的调用问题，实际上在“小罗”写的源程序里面是如下调用的，这样我们也能清晰的看到da和calheight中的int n不是一个概念，同时height数组的值的有效范围是height[1]~height[n]其中height[1]=0，原因就是sa[0]实际上就是我们补的那个0，所以sa[1]和sa[0]的最长公共前缀自然是0。</span></span><br><span class="line">da(r,sa,n+<span class="number">1</span>,<span class="number">128</span>);</span><br><span class="line">calheight(r,sa,n);</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//畅享版，稍加改动</span></span><br><span class="line"><span class="keyword">int</span> wa[ms],wb[ms],wv[ms],wss[ms],rak[ms],height[ms],cal[ms],sa[ms];</span><br><span class="line"><span class="keyword">char</span> s[ms];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> *sa,<span class="keyword">int</span> n,<span class="keyword">int</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,p,*x=wa,*y=wb,*t;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++) wss[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) wss[x[i]=r[i]]++;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;M;i++) wss[i]+=wss[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--wss[x[i]]]=i;  </span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j*=<span class="number">2</span>,M=p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;i++) y[p++]=i;  </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(sa[i]&gt;=j) y[p++]=sa[i]-j;  </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) wv[i]=x[y[i]];  </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++) wss[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) wss[wv[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;M;i++) wss[i]+=wss[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--wss[wv[i]]]=y[i];  </span><br><span class="line">        <span class="keyword">for</span>(t=x,x=y,y=t,p=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        x[sa[i]]=cmp(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calheight</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> *sa,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) rak[sa[i]]=i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;height[rak[i++]]=k)  </span><br><span class="line">    <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rak[i]<span class="number">-1</span>];r[i+k]==r[j+k];k++);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n; i; i--)rak[i]=rak[i<span class="number">-1</span>],sa[i]++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">        da(cal+<span class="number">1</span>,sa,n+<span class="number">1</span>,<span class="number">128</span>);</span><br><span class="line">        calheight(cal+<span class="number">1</span>,sa,n);</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>放一道题：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=6988" >杭电6988</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/stelayuri/p/15080418.html" >题解</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ms=<span class="number">2e5</span>+<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//畅享版</span></span><br><span class="line"><span class="keyword">int</span> wa[ms],wb[ms],wv[ms],wss[ms],rak[ms],height[ms],cal[ms],sa[ms];</span><br><span class="line"><span class="keyword">char</span> s[ms];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+l]==r[b+l];&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">da</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> *sa,<span class="keyword">int</span> n,<span class="keyword">int</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,p,*x=wa,*y=wb,*t;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++) wss[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) wss[x[i]=r[i]]++;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;M;i++) wss[i]+=wss[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--wss[x[i]]]=i;  </span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j*=<span class="number">2</span>,M=p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;i++) y[p++]=i;  </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(sa[i]&gt;=j) y[p++]=sa[i]-j;  </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) wv[i]=x[y[i]];  </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++) wss[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) wss[wv[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;M;i++) wss[i]+=wss[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--wss[wv[i]]]=y[i];  </span><br><span class="line">        <span class="keyword">for</span>(t=x,x=y,y=t,p=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        x[sa[i]]=cmp(y,sa[i<span class="number">-1</span>],sa[i],j)?p<span class="number">-1</span>:p++; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calheight</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> *sa,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) rak[sa[i]]=i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;height[rak[i++]]=k)  </span><br><span class="line">    <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rak[i]<span class="number">-1</span>];r[i+k]==r[j+k];k++);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n; i; i--)rak[i]=rak[i<span class="number">-1</span>],sa[i]++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll k;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">33</span>];</span><br><span class="line"><span class="keyword">int</span> sum[ms];</span><br><span class="line"><span class="comment">// int val[ms];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pos=upper_bound(sum+<span class="number">1</span>,sum+<span class="number">1</span>+n,mid+sum[sa[i]<span class="number">-1</span>])-sum;</span><br><span class="line">        cnt+=(ll)max(<span class="number">0</span>,pos-sa[i]-height[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt&gt;=k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// int x[]=&#123;0,1,2,3,4,5,6,7,8&#125;;</span></span><br><span class="line">    <span class="comment">// printf(&quot;%d\n&quot;,upper_bound(x+1,x+9,6)-x);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %lld&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cal[i]=s[i];</span><br><span class="line">            l=min(l,c[s[i]-<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            sum[i]=sum[i<span class="number">-1</span>]+c[s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        cal[n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        da(cal+<span class="number">1</span>,sa,n+<span class="number">1</span>,<span class="number">128</span>);</span><br><span class="line">        calheight(cal+<span class="number">1</span>,sa,n);</span><br><span class="line"></span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=(ll)(n-sa[i]+<span class="number">1</span>-height[i]);</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">if</span>(k&gt;ans)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> r=sum[n];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(mid))</span><br><span class="line">            &#123;</span><br><span class="line">                r=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/3/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/5/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/header.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">但盼风雨来 能留你在此</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">84</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">16</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">66</div><div class="sidebar-ov-state-item__name">标签</div></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>